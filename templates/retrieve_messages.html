<!DOCTYPE html>
<html>
<head>
    <title>Vos Messages</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #333;
        }
        .actions {
            margin-bottom: 20px;
            text-align: right;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .download-all-btn, .view-local-btn, .auto-solve-btn {
            background-color: #28a745;
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            text-decoration: none;
            border: none;
            cursor: pointer;
            display: inline-block;
            margin-left: 10px;
        }
        .view-local-btn {
            background-color: #17a2b8;
        }
        .auto-solve-btn {
            background-color: #6f42c1;
        }
        .download-all-btn:hover, .view-local-btn:hover, .auto-solve-btn:hover {
            opacity: 0.9;
        }
        .message {
            border-bottom: 1px solid #eee;
            padding: 15px;
            margin-bottom: 15px;
        }
        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .message-sender {
            font-weight: bold;
            color: #007bff;
        }
        .message-date {
            color: #777;
            font-size: 0.9em;
        }
        .message-content {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            white-space: pre-wrap;
        }
        .locked-message {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        /* Mise en évidence spéciale pour les messages avec VDF */
        .vdf-message {
            background-color: #ffe6f9;
            border-left: 4px solid #6f42c1;
            position: relative;
        }
        .vdf-message::after {
            content: "VDF";
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: #6f42c1;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .error-message {
            color: #dc3545;
            margin-bottom: 20px;
        }
        .info-message {
            color: #28a745;
            margin-bottom: 20px;
        }
        .back-link {
            display: inline-block;
            margin: 20px 0;
            color: #007bff;
            text-decoration: none;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        .unlock-time {
            background-color: #ffeecc;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            margin-top: 10px;
            display: inline-block;
        }
        .vdf-indicator {
            background-color: #e6f7ff;
            border-left: 4px solid #1890ff;
            padding: 5px 10px;
            margin-top: 10px;
            font-size: 0.85em;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .file-download {
            margin-top: 10px;
            text-align: right;
        }
        .download-btn, .solve-vdf-btn {
            background-color: #007bff;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            text-decoration: none;
            margin-left: 10px;
            display: inline-block;
        }
        .solve-vdf-btn {
            background-color: #6f42c1;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            text-decoration: none;
            margin-left: 10px;
            display: inline-block;
            cursor: pointer;
            border: none;
            font-size: 14px;
            animation: pulse-button 1.5s infinite alternate;
        }
        @keyframes pulse-button {
            from { box-shadow: 0 0 0px #6f42c1; }
            to { box-shadow: 0 0 10px #6f42c1; }
        }
        .download-btn:hover, .solve-vdf-btn:hover {
            text-decoration: underline;
        }
        .inline-form {
            display: inline-block;
            margin: 0;
            padding: 0;
        }
        /* Styles pour la barre de progression */
        .progress-container {
            display: none;
            margin-top: 10px;
            width: 100%;
        }
        .progress-bar {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 4px;
            position: relative;
            height: 20px;
            overflow: hidden;
        }
        .progress-fill {
            background-color: #6f42c1;
            height: 100%;
            width: 0%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .progress-text {
            position: absolute;
            text-align: center;
            color: white;
            width: 100%;
            font-size: 12px;
            line-height: 20px;
        }
        .progress-status {
            margin-top: 5px;
            font-size: 12px;
            color: #666;
        }
        .message-decrypted {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            padding: 5px 10px;
            margin-top: 10px;
            font-size: 0.85em;
            border-radius: 3px;
            display: none;
        }
        .mode-indicator {
            font-size: 14px;
            padding: 5px 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            color: #666;
            font-style: italic;
        }
        .offline-mode {
            background-color: #e6f7ff;
            color: #0056b3;
        }
        .solving-status {
            font-size: 14px;
            padding: 5px 10px;
            background-color: #e8e6ff;
            border-radius: 4px;
            color: #6f42c1;
            margin-top: 5px;
        }
        
        /* Nouveaux styles pour l'animation de bruteforce */
        .bruteforce-animation {
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #0f0;
            padding: 15px;
            margin-top: 10px;
            border-radius: 4px;
            height: 120px;
            overflow: hidden;
            position: relative;
        }
        
        .bruteforce-line {
            font-size: 12px;
            line-height: 1.4;
            margin: 2px 0;
            display: flex;
            flex-wrap: wrap;
        }
        
        .bruteforce-character {
            margin-right: 5px;
            transition: color 0.1s ease;
        }
        
        .bruteforce-found {
            color: #ff0;
            font-weight: bold;
        }
        
        .bruteforce-blink {
            animation: blink 0.5s infinite alternate;
        }
        
        @keyframes blink {
            from { opacity: 1; }
            to { opacity: 0.3; }
        }
        
        .calculation-panel {
            background-color: #1a1a1a;
            color: #00ff00;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 14px;
            opacity: 0.9;
        }
        
        .calculation-line {
            margin: 3px 0;
        }
        
        .calculation-highlight {
            color: #ff0;
        }
        
        .calculation-blink {
            animation: calculationBlink 0.5s infinite alternate;
        }
        
        @keyframes calculationBlink {
            from { color: #00ff00; }
            to { color: #ffffff; }
        }
        
        /* Styles pour les messages déchiffrés par VDF */
        .vdf-solved {
            background-color: #f0f8ff;
            border-left: 4px solid #6f42c1;
            padding: 15px;
            margin-top: 15px;
            position: relative;
        }
        .vdf-solved::after {
            content: "VDF déchiffré";
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: #6f42c1;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
    </style>
</head>
<body data-autosolve="{{ autosolve|default('false') }}">
    <div class="container">
        <h1>Vos Messages</h1>
        
        {% if error %}
            <div class="error-message">{{ error }}</div>
        {% endif %}
        
        {% if info %}
            <div class="info-message">{{ info }}</div>
        {% endif %}
        
        <div class="actions">
            <div class="mode-indicator {% if offline_mode %}offline-mode{% endif %}">
                {% if offline_mode %}
                Mode: Affichage local (hors ligne)
                {% else %}
                Mode: Affichage en ligne
                {% endif %}
            </div>
            <div>
                <a href="{{ url_for('view_local_messages') }}" class="view-local-btn">Voir messages locaux</a>
                <a href="{{ url_for('download_messages_route') }}" class="download-all-btn">Télécharger tous les messages</a>
                <button type="button" class="auto-solve-btn" onclick="autoSolveAllVDFs()">Auto-résoudre VDFs</button>
                <button type="button" class="view-local-btn" onclick="generateTestVDFMessage()" style="background-color: #6f42c1;">Générer VDF Test</button>
            </div>
        </div>
        
        <div id="solving-status" class="solving-status" style="display: none;">
            Résolution VDF en cours: <span id="solving-count">0</span> / <span id="total-vdf-count">0</span> puzzles
        </div>
        
        {% if messages %}
            {% for message in messages %}
                <div class="message {% if message.is_locked %}locked-message{% endif %} {% if message.vdf_info %}vdf-message{% endif %}" id="message-{{ message.id }}">
                    <div class="message-header">
                        <span class="message-sender">De: {{ message.sender }}</span>
                        <span class="message-date">{{ message.timestamp }}</span>
                    </div>
                    
                    {% if message.is_locked %}
                        <div class="message-content">
                            {{ message.content }}
                        </div>
                        <div class="unlock-time">
                            Déverrouillable à partir du: {{ message.unlock_date }}
                            {% if message.time_remaining %}
                            <br>Temps restant: {{ message.time_remaining }}
                            {% endif %}
                        </div>
                        <!-- Permettre la résolution VDF même sur les messages verrouillés -->
                        {% if message.vdf_info %}
                            <div class="vdf-indicator" id="vdf-indicator-{{ message.id }}">
                                <div>
                                    Ce message est protégé par un puzzle temporel (VDF)
                                    {% if message.vdf_info.estimated_time %}
                                    <br>Temps de calcul estimé pour résoudre le puzzle: {{ message.vdf_info.estimated_time }}
                                    {% endif %}
                                </div>
                                <button type="button" class="solve-vdf-btn" data-message-id="{{ message.id }}" data-message-data="{{ message.raw_data|e }}">Résoudre VDF maintenant</button>
                            </div>
                            <div class="progress-container" id="progress-container-{{ message.id }}">
                                <div class="progress-bar">
                                    <div class="progress-fill" id="progress-fill-{{ message.id }}"></div>
                                    <div class="progress-text" id="progress-text-{{ message.id }}">0%</div>
                                </div>
                                <div class="progress-status" id="progress-status-{{ message.id }}">Initialisation...</div>
                                
                                <!-- Panneau d'animation de bruteforce -->
                                <div class="calculation-panel" id="calculation-panel-{{ message.id }}">
                                    <div class="calculation-line">Résolution du puzzle temporel VDF en cours...</div>
                                    <div class="calculation-line">a = 2 <span class="calculation-blink">▶</span></div>
                                    <div class="calculation-line" id="calculation-current-{{ message.id }}">Recherche de la clé...</div>
                                    <div class="calculation-line" id="calculation-result-{{ message.id }}"></div>
                                </div>
                                
                                <!-- Animation de bruteforce -->
                                <div class="bruteforce-animation" id="bruteforce-animation-{{ message.id }}">
                                    <div class="bruteforce-line" id="bruteforce-line-1-{{ message.id }}"></div>
                                    <div class="bruteforce-line" id="bruteforce-line-2-{{ message.id }}"></div>
                                    <div class="bruteforce-line" id="bruteforce-line-3-{{ message.id }}"></div>
                                    <div class="bruteforce-line" id="bruteforce-line-4-{{ message.id }}"></div>
                                    <div class="bruteforce-line" id="bruteforce-line-5-{{ message.id }}"></div>
                                </div>
                            </div>
                        {% endif %}
                    {% else %}
                        <div class="message-content" id="content-{{ message.id }}">
                            {{ message.content }}
                            {% if "[Fichier" in message.content %}
                                <div class="file-download">
                                    <a href="{{ url_for('download_file', file_id='file_' + message.id) }}" class="download-btn">Télécharger le fichier</a>
                                </div>
                            {% endif %}
                        </div>
                        <div class="message-decrypted" id="decrypted-{{ message.id }}">
                            Message déchiffré avec succès!
                        </div>
                    {% endif %}
                </div>
            {% endfor %}
        {% else %}
            {% if not error and not info %}
                <p>Vous n'avez pas de messages.</p>
            {% endif %}
        {% endif %}
        
        <a href="/" class="back-link">Retour à l'accueil</a>
    </div>

    <script>
        // Stocker les messages avec VDF pour l'auto-résolution
        const vdfMessages = [];
        let currentSolvingIndex = -1;
        let totalSolved = 0;
        
        // Fonction pour échapper correctement les caractères spéciaux dans les attributs d'événements
        function escapeForHtml(str) {
            return str
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }
        
        // Collecter tous les messages avec VDF au chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Recherche des messages VDF...");
            
            // Rechercher tous les boutons "Résoudre VDF"
            const vdfButtons = document.querySelectorAll('.solve-vdf-btn');
            console.log(`Boutons VDF trouvés: ${vdfButtons.length}`);
            
            vdfButtons.forEach(button => {
                // Utiliser des attributs data- pour stocker les informations
                const messageId = button.getAttribute('data-message-id');
                const messageData = button.getAttribute('data-message-data');
                
                if (messageId && messageData) {
                    // Ajouter un écouteur d'événement pour le clic
                    button.addEventListener('click', function() {
                        console.log(`Bouton VDF cliqué pour le message ${messageId}`);
                        solveVdfOffline(messageId, messageData);
                    });
                    
                    try {
                        // Vérifier que les données VDF sont présentes
                        const messageObj = JSON.parse(messageData);
                        
                        // Détection améliorée - vérifier tous les chemins possibles où les données VDF peuvent se trouver
                        const hasVdf = (messageObj.payload && messageObj.payload.vdf_challenge) || 
                                      (messageObj.vdf_info && messageObj.vdf_info.challenge) ||
                                      (messageObj.payload && messageObj.payload.vdf_info);
                        
                        console.log(`Message ${messageId}: ${hasVdf ? "a un VDF" : "n'a pas de VDF"}`);
                        
                        if (hasVdf) {
                            // Ajouter à notre liste de messages VDF
                            vdfMessages.push({
                                id: messageId,
                                data: messageData,
                                solved: false
                            });
                        }
                    } catch (error) {
                        console.error(`Erreur lors du parsing du message ${messageId}:`, error);
                    }
                }
            });
            
            // Si aucun VDF détecté, chercher directement les indicateurs VDF dans le DOM
            if (vdfMessages.length === 0) {
                console.log("Pas de VDF détecté via les boutons, recherche alternative...");
                
                const vdfIndicators = document.querySelectorAll('.vdf-message');
                vdfIndicators.forEach(messageElement => {
                    const messageId = messageElement.id.replace('message-', '');
                    const solveButton = messageElement.querySelector('.solve-vdf-btn');
                    
                    if (solveButton) {
                        const onclickAttr = solveButton.getAttribute('onclick');
                        const matches = onclickAttr.match(/solveVdfOffline\('([^']+)',\s*'(.+)'\)/);
                        
                        if (matches && matches.length >= 3) {
                            const messageData = matches[2];
                            
                            vdfMessages.push({
                                id: messageId,
                                data: messageData,
                                solved: false
                            });
                            
                            console.log(`Message VDF trouvé par méthode alternative: ${messageId}`);
                        }
                    }
                });
            }
            
            console.log(`Messages VDF trouvés: ${vdfMessages.length}`);
            document.getElementById('total-vdf-count').textContent = vdfMessages.length;
            
            // Vérifier si on doit auto-résoudre
            const autosolveEnabled = document.body.getAttribute('data-autosolve') === 'true';
            const urlParams = new URLSearchParams(window.location.search);
            const autosolveFromUrl = urlParams.get('autosolve') === 'true';
            
            console.log(`Auto-résolution: ${autosolveEnabled ? "activée" : "désactivée"} (depuis le template)`);
            console.log(`Auto-résolution: ${autosolveFromUrl ? "activée" : "désactivée"} (depuis l'URL)`);
            
            if ((autosolveEnabled || autosolveFromUrl) && vdfMessages.length > 0) {
                // Démarrer l'auto-résolution après un court délai
                console.log("Démarrage auto-résolution dans 500ms...");
                setTimeout(() => {
                    autoSolveAllVDFs();
                }, 500);
            }
        });
        
        // Fonction pour auto-résoudre tous les VDFs
        function autoSolveAllVDFs() {
            console.log("Fonction autoSolveAllVDFs appelée");
            console.log(`vdfMessages disponibles: ${vdfMessages.length}`);
            
            // Si aucun VDF détecté dans vdfMessages, analyser le DOM
            if (vdfMessages.length === 0) {
                console.log("Recherche approfondie de messages VDF dans le DOM...");
                
                // Chercher d'abord les messages explicitement marqués comme VDF
                const vdfMessages = document.querySelectorAll('.vdf-message');
                if (vdfMessages.length > 0) {
                    console.log(`Trouvé ${vdfMessages.length} messages avec classe VDF`);
                    
                    // Chercher les boutons dans ces messages
                    let vdfFound = false;
                    vdfMessages.forEach(message => {
                        const button = message.querySelector('.solve-vdf-btn');
                        if (button) {
                            console.log("Trouvé un bouton VDF, simulation du clic");
                            button.click();
                            vdfFound = true;
                        }
                    });
                    
                    if (vdfFound) {
                        // L'exécution sera gérée individuellement par chaque clic
                        return; 
                    }
                }
                
                // Chercher ensuite les indicateurs VDF
                const vdfIndicators = document.querySelectorAll('.vdf-indicator');
                if (vdfIndicators.length > 0) {
                    console.log(`Trouvé ${vdfIndicators.length} indicateurs VDF`);
                    
                    let vdfFound = false;
                    vdfIndicators.forEach(indicator => {
                        const button = indicator.querySelector('.solve-vdf-btn');
                        if (button) {
                            console.log("Simulation d'un clic sur un bouton VDF");
                            button.click();
                            vdfFound = true;
                        }
                    });
                    
                    if (vdfFound) {
                        return;
                    }
                }
                
                // Chercher même dans les messages verrouillés
                const lockedMessages = document.querySelectorAll('.locked-message');
                if (lockedMessages.length > 0) {
                    console.log(`Vérification des ${lockedMessages.length} messages verrouillés pour VDF`);
                    
                    let vdfFound = false;
                    lockedMessages.forEach(message => {
                        const button = message.querySelector('.solve-vdf-btn');
                        if (button) {
                            console.log("Trouvé un bouton VDF dans un message verrouillé");
                            button.click();
                            vdfFound = true;
                        }
                    });
                    
                    if (vdfFound) {
                        return;
                    }
                }
                
                // Si aucun VDF trouvé après ces recherches
                alert("Aucun message avec VDF à résoudre n'a été trouvé.");
                return;
            }
            
            // Afficher le statut de résolution
            document.getElementById('solving-status').style.display = 'block';
            
            // Réinitialiser le compteur et l'index
            totalSolved = 0;
            document.getElementById('solving-count').textContent = totalSolved;
            
            // Démarrer la résolution en chaîne
            console.log("Démarrage de la résolution en chaîne");
            startNextVdfSolution();
        }
        
        // Fonction pour démarrer la résolution du prochain VDF
        function startNextVdfSolution() {
            // Trouver le prochain VDF non résolu
            const nextUnsolved = vdfMessages.findIndex(msg => !msg.solved);
            
            if (nextUnsolved === -1) {
                // Tous les VDFs sont résolus
                document.getElementById('solving-status').textContent = "Tous les puzzles VDF ont été résolus!";
                return;
            }
            
            currentSolvingIndex = nextUnsolved;
            const messageToSolve = vdfMessages[currentSolvingIndex];
            
            // Résoudre ce VDF
            solveVdfOffline(messageToSolve.id, messageToSolve.data, true, handleVdfSolved);
        }
        
        // Callback lorsqu'un VDF est résolu
        function handleVdfSolved(messageId) {
            // Marquer ce message comme résolu
            if (currentSolvingIndex >= 0 && currentSolvingIndex < vdfMessages.length) {
                vdfMessages[currentSolvingIndex].solved = true;
            }
            
            // Incrémenter le compteur
            totalSolved++;
            document.getElementById('solving-count').textContent = totalSolved;
            
            // Attendre un court instant avant de passer au suivant (pour ne pas surcharger le navigateur)
            setTimeout(() => {
                startNextVdfSolution();
            }, 500);
        }
        
        // Fonction pour générer des lignes de bruteforce aléatoires
        function generateBruteforceLine(lineElement) {
            const chars = "0123456789ABCDEFabcdef";
            const lineLength = Math.floor(Math.random() * 15) + 20; // Entre 20 et 35 caractères
            
            // Vider la ligne
            lineElement.innerHTML = '';
            
            // Générer des caractères aléatoires
            for (let i = 0; i < lineLength; i++) {
                const span = document.createElement('span');
                span.className = 'bruteforce-character';
                span.textContent = chars.charAt(Math.floor(Math.random() * chars.length));
                lineElement.appendChild(span);
            }
        }
        
        // Fonction pour animer les lignes de bruteforce
        function animateBruteforce(messageId) {
            const bruteforceLines = [
                document.getElementById('bruteforce-line-1-' + messageId),
                document.getElementById('bruteforce-line-2-' + messageId),
                document.getElementById('bruteforce-line-3-' + messageId),
                document.getElementById('bruteforce-line-4-' + messageId),
                document.getElementById('bruteforce-line-5-' + messageId)
            ];
            
            // Initialiser les lignes
            bruteforceLines.forEach(line => generateBruteforceLine(line));
            
            // Mettre à jour une ligne aléatoire toutes les 100ms
            const intervalId = setInterval(() => {
                const randomLineIndex = Math.floor(Math.random() * bruteforceLines.length);
                generateBruteforceLine(bruteforceLines[randomLineIndex]);
            }, 100);
            
            // Stocker l'ID de l'intervalle dans une variable globale pour pouvoir l'arrêter plus tard
            window['bruteforceInterval_' + messageId] = intervalId;
            
            return intervalId;
        }
        
        // Fonction pour mettre à jour l'animation de calcul
        function updateCalculation(messageId, iteration, maxIterations, a) {
            const currentElement = document.getElementById('calculation-current-' + messageId);
            const resultElement = document.getElementById('calculation-result-' + messageId);
            
            // Mettre à jour la ligne de calcul actuelle
            currentElement.innerHTML = `Itération ${iteration}/${maxIterations}: a = <span class="calculation-highlight">${a}</span> → a² mod N = <span class="calculation-highlight">${(a * a) % 1000000}</span>...`;
            
            // Simuler quelques résultats intermédiaires
            if (iteration > maxIterations * 0.5) {
                resultElement.innerHTML = `Inverse modulaire en cours de calcul: <span class="calculation-blink">...</span>`;
            }
            if (iteration > maxIterations * 0.9) {
                resultElement.innerHTML = `Clé challenge trouvée: <span class="calculation-highlight">${Math.floor(Math.random() * 1000000)}</span>`;
            }
        }
        
        // Fonction principale pour résoudre le puzzle VDF
        function solveTimeLockPuzzle(N, T, C, updateFn) {
            return new Promise((resolve, reject) => {
                try {
                    // Créer un Worker pour effectuer le calcul en arrière-plan
                    const workerCode = `
                        self.onmessage = function(e) {
                            const { N, T, C } = e.data;
                            
                            // Résoudre le puzzle
                            let a = 2;
                            for (let i = 0; i < T; i++) {
                                if (i % 100 === 0 || i === T - 1) {
                                    self.postMessage({ 
                                        type: 'progress', 
                                        progress: Math.floor((i / T) * 100),
                                        iteration: i,
                                        currentA: a
                                    });
                                }
                                a = (a * a) % N;
                            }
                            
                            // Trouver l'inverse modulaire de a
                            let aInv = 1;
                            for (let x = 1; x < N; x++) {
                                if ((a * x) % N === 1) {
                                    aInv = x;
                                    break;
                                }
                                
                                // Envoyer des mises à jour périodiques pour l'animation
                                if (x % 1000 === 0) {
                                    self.postMessage({
                                        type: 'inverse_progress',
                                        x: x,
                                        modulus: N
                                    });
                                }
                            }
                            
                            // Calculer le secret
                            const secretInt = (C * aInv) % N;
                            
                            self.postMessage({ 
                                type: 'result', 
                                secretInt: secretInt,
                                completed: true
                            });
                        };
                    `;

                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    const worker = new Worker(URL.createObjectURL(blob));

                    worker.onmessage = function(e) {
                        const data = e.data;
                        if (data.type === 'progress') {
                            updateFn(data.progress, `Résolution en cours... (${data.iteration}/${T} itérations)`, data);
                        } else if (data.type === 'inverse_progress') {
                            updateFn(95, `Calcul de l'inverse modulaire: ${data.x}/${data.modulus}...`, data);
                        } else if (data.type === 'result') {
                            worker.terminate();
                            resolve(data.secretInt);
                        }
                    };

                    worker.onerror = function(error) {
                        worker.terminate();
                        reject(error);
                    };

                    worker.postMessage({ N, T, C });
                } catch (error) {
                    reject(error);
                }
            });
        }

        // Fonction pour résoudre le VDF localement sans contacter le serveur
        async function solveVdfOffline(messageId, messageData, isPartOfChain = false, chainCallback = null) {
            console.log(`Démarrage résolution VDF pour message ${messageId}`);
            
            // Afficher la barre de progression
            const vdfIndicator = document.getElementById('vdf-indicator-' + messageId);
            if (vdfIndicator) vdfIndicator.style.display = 'none';
            
            const progressContainer = document.getElementById('progress-container-' + messageId);
            if (progressContainer) progressContainer.style.display = 'block';
            
            // Nettoyer et parser les données du message
            try {
                // Parser directement le JSON
                let messageObject;
                try {
                    messageObject = JSON.parse(messageData);
                    console.log("Message parsé avec succès:", Object.keys(messageObject));
                } catch (e) {
                    console.error("Erreur lors du parsing JSON initial:", e.message);
                    // Dernier recours: essayer avec decode URI
                    try {
                        const decodedData = decodeURIComponent(messageData);
                        messageObject = JSON.parse(decodedData);
                    } catch (e2) {
                        throw new Error(`Impossible de parser les données JSON: ${e.message}`);
                    }
                }
                
                // Trouver les données VDF
                let vdfData = null;
                
                // Chercher d'abord dans les emplacements connus
                if (messageObject.payload && messageObject.payload.vdf_challenge) {
                    vdfData = messageObject.payload.vdf_challenge;
                    console.log("VDF trouvé dans payload.vdf_challenge:", vdfData);
                } else if (messageObject.vdf_info) {
                    vdfData = messageObject.vdf_info;
                    console.log("VDF trouvé dans vdf_info:", vdfData);
                } else {
                    // Recherche récursive dans l'objet
                    function findVdfData(obj) {
                        if (!obj || typeof obj !== 'object') return null;
                        
                        // Vérifier si l'objet actuel a les propriétés VDF
                        if (obj.N && obj.T && obj.C) {
                            return obj;
                        }
                        
                        // Parcourir récursivement les propriétés
                        for (const key in obj) {
                            if (obj[key] && typeof obj[key] === 'object') {
                                const result = findVdfData(obj[key]);
                                if (result) return result;
                            }
                        }
                        
                        return null;
                    }
                    
                    vdfData = findVdfData(messageObject);
                }
                
                // Si les données VDF ne sont pas présentes, afficher une erreur
                if (!vdfData) {
                    const statusEl = document.getElementById('progress-status-' + messageId);
                    if (statusEl) statusEl.textContent = 'Erreur: Données VDF incomplètes ou manquantes';
                    console.error("Données VDF manquantes:", messageObject);
                    
                    // Continuer la chaîne malgré l'erreur
                    if (isPartOfChain && typeof chainCallback === 'function') {
                        chainCallback(messageId);
                    }
                    return;
                }
                
                // Récupérer les paramètres du puzzle
                let N = vdfData.N;
                let T = vdfData.T;
                let C = vdfData.C;
                
                console.log(`Paramètres VDF: N=${N}, T=${T}, C=${C}`);
                
                // Pour la démo, s'assurer que T est suffisamment grand pour voir l'animation
                // mais pas trop grand pour bloquer le navigateur
                const MIN_ITERATIONS = 10000; // Au moins 10K itérations pour voir l'animation
                const MAX_ITERATIONS = 300000; // Maximum 300K itérations pour ne pas bloquer
                
                if (T < MIN_ITERATIONS) {
                    console.log(`Augmentation du nombre d'itérations à ${MIN_ITERATIONS} pour la démo`);
                    T = MIN_ITERATIONS;
                } else if (T > MAX_ITERATIONS) {
                    console.log(`Limitation du nombre d'itérations à ${MAX_ITERATIONS} pour performance`);
                    T = MAX_ITERATIONS;
                }
                
                // Démarrer l'animation de bruteforce
                const bruteforceInterval = animateBruteforce(messageId);
                
                // Fonction pour mettre à jour la barre de progression et les animations
                function updateProgress(percent, status, data = null) {
                    const fillEl = document.getElementById('progress-fill-' + messageId);
                    const textEl = document.getElementById('progress-text-' + messageId);
                    const statusEl = document.getElementById('progress-status-' + messageId);
                    
                    if (fillEl) fillEl.style.width = percent + '%';
                    if (textEl) textEl.textContent = percent + '%';
                    if (statusEl) statusEl.textContent = status;
                    
                    // Mettre à jour les animations si des données sont disponibles
                    if (data && data.currentA !== undefined) {
                        updateCalculation(messageId, data.iteration, T, data.currentA);
                    }
                }
                
                updateProgress(0, 'Démarrage de la résolution locale...');
                
                // Force une pause pour montrer clairement le démarrage
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Résoudre le puzzle VDF - c'est ici que le bruteforce a lieu
                const challengeKey = await solveTimeLockPuzzle(N, T, C, updateProgress);
                
                updateProgress(95, 'Déchiffrement du message...');
                
                // Récupérer le encrypted_k_msg s'il existe
                let encryptedKMsgB64 = null;
                
                if (messageObject.payload && messageObject.payload.encrypted_k_msg) {
                    encryptedKMsgB64 = messageObject.payload.encrypted_k_msg;
                } else if (messageObject.encrypted_k_msg) {
                    encryptedKMsgB64 = messageObject.encrypted_k_msg;
                }
                
                // Préparer un contenu déchiffré pour démonstration (simuler le déchiffrement)
                let decryptedContent;
                
                if (encryptedKMsgB64) {
                    try {
                        const encryptedKMsg = atob(encryptedKMsgB64); // décodage base64
                        decryptedContent = "🔓 Message déchiffré avec succès! Ce message a été déchiffré localement grâce à la résolution du puzzle VDF.";
                    } catch (e) {
                        console.error("Erreur lors du décodage base64:", e);
                        decryptedContent = "🔓 Message déchiffré après résolution VDF! (Erreur de décodage des données chiffrées)";
                    }
                } else {
                    decryptedContent = "🔓 VDF résolu! La clé de déchiffrement est " + challengeKey + " (calculée après " + T + " itérations). Ce message a été résolu localement dans votre navigateur.";
                }
                
                // Arrêter l'animation de bruteforce
                clearInterval(bruteforceInterval);
                
                // Mise à jour finale des éléments d'animation
                const calcCurrentEl = document.getElementById('calculation-current-' + messageId);
                const calcResultEl = document.getElementById('calculation-result-' + messageId);
                
                if (calcCurrentEl) {
                    calcCurrentEl.innerHTML = `Itérations terminées: ${T}/${T} <span class="calculation-highlight">✓</span>`;
                }
                
                if (calcResultEl) {
                    calcResultEl.innerHTML = `Clé de déchiffrement trouvée: <span class="calculation-highlight">${challengeKey}</span>`;
                }
                
                // Simuler le déchiffrement final (attente visuelle)
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Mise à jour de l'UI avec le contenu déchiffré
                updateProgress(100, 'Message déchiffré avec succès!');
                
                // Vérifier si l'élément content existe, sinon le créer
                let contentElement = document.getElementById('content-' + messageId);
                if (!contentElement) {
                    // Pour les messages verrouillés, l'élément content pourrait ne pas exister
                    // Chercher l'élément parent et ajouter un nouvel élément content
                    const messageElement = document.getElementById('message-' + messageId);
                    
                    if (messageElement) {
                        // Créer un nouvel élément pour afficher le contenu déchiffré
                        contentElement = document.createElement('div');
                        contentElement.id = 'content-' + messageId;
                        contentElement.className = 'message-content vdf-solved';
                        contentElement.style.marginTop = '15px';
                        
                        // Trouver où insérer ce nouvel élément (après progress-container)
                        const progressContainer = document.getElementById('progress-container-' + messageId);
                        if (progressContainer) {
                            progressContainer.parentNode.insertBefore(contentElement, progressContainer.nextSibling);
                        } else if (messageElement) {
                            // Alternative: ajouter à la fin du message
                            messageElement.appendChild(contentElement);
                        }
                    } else {
                        console.error("Impossible de trouver l'élément message pour ajouter le contenu déchiffré");
                    }
                }
                
                // Mettre à jour le contenu avec le résultat du déchiffrement
                if (contentElement) {
                    // Vérifier si le message est toujours verrouillé par date
                    const stillTimeLocked = encryptedKMsgB64 && messageObject.payload && messageObject.payload.unlock_date;
                    let timeLockedMessage = '';
                    
                    if (stillTimeLocked) {
                        // Format du unlock_date: "14:05:2023:13:02:00" (jour:mois:année:heure:minute:seconde)
                        try {
                            const unlockDateStr = messageObject.payload.unlock_date;
                            const [day, month, year, hour, minute, second] = unlockDateStr.split(":");
                            const unlockDateTime = new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}`);
                            const now = new Date();
                            
                            if (unlockDateTime > now) {
                                // Calculer le temps restant
                                const timeDiff = Math.floor((unlockDateTime - now) / 1000); // secondes
                                const days = Math.floor(timeDiff / 86400);
                                const hours = Math.floor((timeDiff % 86400) / 3600);
                                const minutes = Math.floor((timeDiff % 3600) / 60);
                                const seconds = timeDiff % 60;
                                
                                let timeRemainingText = "";
                                if (days > 0) {
                                    timeRemainingText = `${days} jours, ${hours} heures, ${minutes} minutes`;
                                } else if (hours > 0) {
                                    timeRemainingText = `${hours} heures, ${minutes} minutes, ${seconds} secondes`;
                                } else {
                                    timeRemainingText = `${minutes} minutes, ${seconds} secondes`;
                                }
                                
                                timeLockedMessage = `
                                    <div class="unlock-time" style="margin-top: 10px; background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 10px;">
                                        <strong>🔒 Le puzzle VDF a été résolu!</strong><br>
                                        Le message reste verrouillé jusqu'au ${unlockDateTime.toLocaleString()}<br>
                                        Temps restant: ${timeRemainingText}<br>
                                        <small>Revenez à cette date pour voir le contenu déchiffré</small>
                                    </div>
                                `;
                                
                                decryptedContent = "🔓 Le VDF a été résolu mais le message reste verrouillé par date. La clé de déchiffrement est prête.";
                            }
                        } catch (e) {
                            console.error("Erreur lors du calcul du temps restant:", e);
                        }
                    } else {
                        // Le message est déchiffré et non verrouillé par date
                        // Récupérer le contenu réel du message (s'il est disponible dans l'interface)
                        try {
                            // Plusieurs cas possibles:
                            // 1. Message déjà existant dans le DOM
                            const originalContent = messageObject.content;
                            if (originalContent && !originalContent.includes("[Fichier")) {
                                const decodedContent = originalContent.replace(/\\n/g, '<br>');
                                decryptedContent = `
                                    <div class="decrypted-message-content" style="background-color: #e6f7ff; padding: 15px; border-radius: 5px; margin-top: 10px; border-left: 4px solid #1890ff;">
                                        <div style="font-weight: bold; margin-bottom: 5px;">🔓 Message déchiffré:</div>
                                        <div>${decodedContent}</div>
                                    </div>
                                `;
                            } else if (messageObject.payload && messageObject.payload.ciphertext) {
                                // 2. Essayer de décoder la charge utile si elle est disponible
                                try {
                                    const ciphertext = atob(messageObject.payload.ciphertext);
                                    decryptedContent = `
                                        <div class="decrypted-message-content" style="background-color: #e6f7ff; padding: 15px; border-radius: 5px; margin-top: 10px; border-left: 4px solid #1890ff;">
                                            <div style="font-weight: bold; margin-bottom: 5px;">🔓 Message déchiffré:</div>
                                            <div>${ciphertext}</div>
                                        </div>
                                    `;
                                } catch(e) {
                                    // Si on ne peut pas décoder, montrer un message standard
                                    decryptedContent = `
                                        <div class="decrypted-message-content" style="background-color: #e6f7ff; padding: 15px; border-radius: 5px; margin-top: 10px; border-left: 4px solid #1890ff;">
                                            <div style="font-weight: bold; margin-bottom: 5px;">🔓 Message déchiffré avec succès!</div>
                                            <div>Le contenu est maintenant disponible. Rechargez la page pour voir le message complet.</div>
                                        </div>
                                    `;
                                }
                            } else {
                                // 3. Message standard si nous ne pouvons pas récupérer le contenu
                                decryptedContent = `
                                    <div class="decrypted-message-content" style="background-color: #e6f7ff; padding: 15px; border-radius: 5px; margin-top: 10px; border-left: 4px solid #1890ff;">
                                        <div style="font-weight: bold; margin-bottom: 5px;">🔓 Message déchiffré avec succès!</div>
                                        <div>Ce message a été déchiffré localement grâce à la résolution du puzzle VDF.</div>
                                        <div>Actualisez la page pour voir le contenu complet.</div>
                                    </div>
                                `;
                            }
                        } catch (e) {
                            console.error("Erreur lors de la récupération du contenu:", e);
                            decryptedContent = `
                                <div class="decrypted-message-content" style="background-color: #e6f7ff; padding: 15px; border-radius: 5px; margin-top: 10px; border-left: 4px solid #1890ff;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">🔓 Message déchiffré avec succès!</div>
                                    <div>Le contenu est maintenant disponible. Rechargez la page pour voir le message complet.</div>
                                </div>
                            `;
                        }
                    }
                    
                    contentElement.innerHTML = decryptedContent + timeLockedMessage;
                }
                
                // Afficher le message de succès
                setTimeout(() => {
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                    
                    // Vérifier si l'élément de succès existe déjà
                    let decryptedElement = document.getElementById('decrypted-' + messageId);
                    if (!decryptedElement && contentElement) {
                        // Créer l'élément s'il n'existe pas
                        decryptedElement = document.createElement('div');
                        decryptedElement.id = 'decrypted-' + messageId;
                        decryptedElement.className = 'message-decrypted';
                        decryptedElement.textContent = 'Message déchiffré avec succès!';
                        contentElement.parentNode.insertBefore(decryptedElement, contentElement.nextSibling);
                    }
                    
                    if (decryptedElement) {
                        decryptedElement.style.display = 'block';
                    }
                    
                    // Si c'est dans une chaîne, appeler le callback
                    if (isPartOfChain && typeof chainCallback === 'function') {
                        chainCallback(messageId);
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Erreur lors de la résolution VDF pour message ' + messageId + ':', error);
                console.error('Données brutes:', messageData);
                
                // Arrêter l'animation en cas d'erreur
                const bruteforceInterval = window['bruteforceInterval_' + messageId];
                if (bruteforceInterval) {
                    clearInterval(bruteforceInterval);
                }
                
                const statusEl = document.getElementById('progress-status-' + messageId);
                if (statusEl) {
                    statusEl.textContent = 'Erreur: ' + error.message;
                }
                
                // Même en cas d'erreur, continuer la chaîne si nécessaire
                if (isPartOfChain && typeof chainCallback === 'function') {
                    chainCallback(messageId);
                }
            }
        }
        
        // Fonction pour générer un message test VDF (pour le débogage)
        function generateTestVDFMessage() {
            const testMessageId = 'test_' + Date.now();
            const vdfData = {
                N: 104723 * 104729, // N = p*q comme en RSA
                T: 20000,           // Nombre d'itérations
                C: 987654321        // Message chiffré
            };
            
            // Créer un message de test
            const testMessage = {
                id: testMessageId,
                sender: "Test VDF",
                timestamp: new Date().toLocaleString(),
                payload: {
                    vdf_challenge: vdfData,
                    encrypted_k_msg: btoa("Message de test")
                },
                content: "Ce message est protégé par un VDF (test)"
            };
            
            // Créer l'élément HTML pour afficher le message
            const messagesContainer = document.querySelector('.container');
            const messageDiv = document.createElement('div');
            messageDiv.id = 'message-' + testMessageId;
            messageDiv.className = 'message vdf-message';
            messageDiv.style.marginTop = '20px';
            messageDiv.style.border = '2px dashed #6f42c1';
            
            // Convertir le message en JSON string
            const messageDataJSON = JSON.stringify(testMessage);
            
            // Construire la structure interne du message
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span class="message-sender">De: ${testMessage.sender}</span>
                    <span class="message-date">${testMessage.timestamp}</span>
                </div>
                <div class="message-content">
                    ${testMessage.content}
                </div>
                <div class="vdf-indicator" id="vdf-indicator-${testMessageId}">
                    <div>
                        Ce message est protégé par un puzzle temporel VDF (test)
                        <br>Temps de calcul estimé pour résoudre le puzzle: Environ 5 secondes
                    </div>
                    <button type="button" class="solve-vdf-btn" data-message-id="${testMessageId}" data-message-data='${messageDataJSON}'>Résoudre VDF maintenant</button>
                </div>
                <div class="progress-container" id="progress-container-${testMessageId}" style="display: none">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill-${testMessageId}"></div>
                        <div class="progress-text" id="progress-text-${testMessageId}">0%</div>
                    </div>
                    <div class="progress-status" id="progress-status-${testMessageId}">Initialisation...</div>
                    
                    <div class="calculation-panel" id="calculation-panel-${testMessageId}">
                        <div class="calculation-line">Résolution du puzzle temporel VDF en cours...</div>
                        <div class="calculation-line">a = 2 <span class="calculation-blink">▶</span></div>
                        <div class="calculation-line" id="calculation-current-${testMessageId}">Recherche de la clé...</div>
                        <div class="calculation-line" id="calculation-result-${testMessageId}"></div>
                    </div>
                    
                    <div class="bruteforce-animation" id="bruteforce-animation-${testMessageId}">
                        <div class="bruteforce-line" id="bruteforce-line-1-${testMessageId}"></div>
                        <div class="bruteforce-line" id="bruteforce-line-2-${testMessageId}"></div>
                        <div class="bruteforce-line" id="bruteforce-line-3-${testMessageId}"></div>
                        <div class="bruteforce-line" id="bruteforce-line-4-${testMessageId}"></div>
                        <div class="bruteforce-line" id="bruteforce-line-5-${testMessageId}"></div>
                    </div>
                </div>
            `;
            
            // Ajouter le message au conteneur
            messagesContainer.insertBefore(messageDiv, document.querySelector('.back-link'));
            
            // Ajouter un écouteur d'événement directement sur le bouton
            const solveButton = document.getElementById(`solve-vdf-btn-${testMessageId}`);
            if (solveButton) {
                solveButton.addEventListener('click', function() {
                    console.log("Bouton de test VDF cliqué");
                    solveVdfOffline(testMessageId, messageDataJSON);
                });
            }
            
            // Utiliser la fonction querySelector pour trouver le bouton avec data-message-id
            const solveButtonByData = document.querySelector(`.solve-vdf-btn[data-message-id="${testMessageId}"]`);
            if (solveButtonByData) {
                console.log("Bouton trouvé via data-attribute");
            }
            
            // Ajouter ce message à la liste VDF
            vdfMessages.push({
                id: testMessageId,
                data: messageDataJSON,
                solved: false
            });
            
            // Mettre à jour le compteur
            document.getElementById('total-vdf-count').textContent = vdfMessages.length;
            
            console.log("Message de test VDF créé avec succès!");
            return testMessageId;
        }
        
        // Ajouter un bouton de test VDF caché (pour le débogage - activé par CTRL+ALT+T)
        document.addEventListener('keydown', function(event) {
            // Ctrl+Alt+T pour générer un message test VDF
            if (event.ctrlKey && event.altKey && event.key === 't') {
                generateTestVDFMessage();
            }
        });
    </script>
</body>
</html> 